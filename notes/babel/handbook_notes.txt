
Also, alles besteht aus Nodes, die eine Reihe von Infos über den
entsprechenden Teil des Codes besitzen.

Identifier, FunctionDeclaration, Positionen innerhalb des Codes etc.

Namen.

expression true oder false.

---

BABEL macht drei Sachen:

parsen, transformen, generieren.

Das parsen, mutmaßlich, übernimmt Babel komplett für mich.

Dann habe ich den AST und kann mit diesem arbeiten.

tokens, als zwischenstand vor dem eigentlich fertig kompilierten ast.

und dann die TRANSFORM stage.

Das ist das, was mich interessiert. Ich will bestimmte Nodes in den
AST einhängen.

Und ich werde tree traversal betreiben müssen, das heißt durch den
kompletten baum einmal durchlaufen.

---

visitors:

visitors sind die pattern, mit denen man die nodes an den
verschiedenen stellen besucht.

Ich werde also in jedem Fall auch Visitors erstellen müssen für mein
Plugin.

Also, man kann Visitors erstellen und diese bekommen dann bestimmte
Methoden, die bestimmten Node-Typen entsprechen, und immer wenn dann
einer dieser Node-Typen gefunden wird, wird das ausgeführt, was in dem
Visitor stattfindet.

Evtl. kann ich auch aliase definieren für bestimmte Node-Gruppen.

Evtl: Eine bestimmte Gruppe auswählen und predefinieren und dann
hinterher nur in dieser Gruppe loggen!

path.node.name

---

STATE

Die potenziellen State-Probleme, die in den Docs erwähnt werden,
können auch bei mir aufkommen.

---

SCOPES

(...)

---

Grundsätzlich besteht babel aus einem haufen module, die verschiedene
Dinge erledigen. Ich nutze davon mutmaßlich manche, andere wiederum
werde ich gar nicht brauchen.

---

Mit Babylon parse ich. Das heißt, das brauche ich mutmaßlich an den
AST zu kommen.

Es sei denn, dafür gibt es plugin build funktionalitäten.

---

traverse-types läuft dann irgendwie doch, aber nicht ganz wie in den
docs beschrieben. Angeblich kann ich damit solide im ast herumlaufen
und rumschreiben, was ich brauchen werde.

babel-types wirkt ein bisschen so wie jquery für babel. helper
utilitys noch und nöcher.

richtig geil scheint die Funktion "defineType" zu sein: Damit kann man
einfach ein node bauen.
--> Übung für mich: Einmal mit define Type etwas bauen und daraus dann
kompilierbaren js code machen.

und dazu dann die builder funktionen. Man kann also gewissermaßen eine
vorlage für console log in diesem ast sprech schreiben.

welche dann hoffentlich sehr bald sehr dynamisch zugriff hat auf teile
des von mir ausgewählten codes!

---

und dann gibt es den babel-generator, der wiederum sozusagen das
gegenstück zu babylon ist, und also den Code zurückübersetzt, von ast
in code.

damit habe ich eigentlich alles.

Sehr geil siehe mein test4

// Sehr geil: Allein mit Hilfe dieser drei Module laufe ich einmal
// rein in den ast, ändere dort eine Kleinigkeit, und laufe wieder
// raus und habe neuen Code, der andere Variablennamen hat!

Und da man generate sogar simple Optionen übergeben kann, habe ich
allein mit diesem Spaß vermutlich das Semikolonproblem vom Wochenende
locker gelöst!!
